package gen

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/koskimas/norsu/internal/config"
	"github.com/koskimas/norsu/internal/match"
	"github.com/koskimas/norsu/internal/model"
	"github.com/koskimas/norsu/internal/pg"
	"github.com/koskimas/norsu/internal/ptr"
)

const (
	idParamInput   = "in"
	idParamDb      = "db"
	idParamCtx     = "ctx"
	idParamQueries = "q"
	idParamQuery   = "query"
	idParamArgs    = "args"

	idVarRows         = "rows"
	idVarRow          = "row"
	idVarErr          = "err"
	idVarOutput       = "out"
	idVarInputSuffix  = "In"
	idVarOutputSuffix = "Out"

	idPropDb           = "DB"
	idInterfaceDb      = "DB"
	idInterfaceQueries = "Queries"
	idStructQueries    = "QueriesImpl"
	idFuncNewQueries   = "New"
	idStructIntArray   = "IntArray"
)

var (
	queryLocalVars = []string{
		idVarErr,
		idVarRows,
		idVarRow,
		idParamCtx,
		idParamInput,
		idVarOutput,
		idParamQueries,
	}
)

func GenerateCode(
	cfg config.Config,
	workingDir string,
	models map[string]model.Model,
	queries []pg.Query,
) error {
	f := jen.NewFile(path.Base(cfg.Package.Path))

	f.HeaderComment(`Code generated by Norsu; DO NOT EDIT.`)
	f.ImportAlias("github.com/jackc/pgx/v5", "pgx")

	genQueryInterface(f, models, queries)
	genDBInterface(f)
	genQueriesStruct(f)
	genNewFunc(f)

	for _, q := range queries {
		var im, om *model.Model

		if q.In != nil {
			im = ptr.V(models[q.In.Model])
		}

		if q.Out != nil {
			om = ptr.V(models[q.Out.Model])
		}

		genQuery(f, q, im, om)
	}

	return writeQueriesToFile(f, cfg, workingDir)
}

func genQueryInterface(f *jen.File, models map[string]model.Model, queries []pg.Query) {
	f.Type().Id(idInterfaceQueries).InterfaceFunc(func(g *jen.Group) {
		for _, q := range queries {
			g.Id(q.Name).ParamsFunc(func(g *jen.Group) {
				g.Id(idParamCtx).Qual("context", "Context")

				if q.In != nil {
					im := models[q.In.Model]
					g.Id(idParamInput).Qual(im.Package, im.Name)
				}
			}).ParamsFunc(func(g *jen.Group) {
				if q.Out != nil {
					om := models[q.Out.Model]
					g.Index().Qual(om.Package, om.Name)
				}

				g.Error()
			})
		}
	})
	f.Empty()
}

func genDBInterface(f *jen.File) {
	f.Type().Id(idInterfaceDb).Interface(
		jen.Id("Query").Params(
			jen.Id(idParamCtx).Qual("context", "Context"),
			jen.Id(idParamQuery).String(),
			jen.Id(idParamArgs).Op("...").Id("any"),
		).Params(
			jen.Qual("github.com/jackc/pgx/v5", "Rows"),
			jen.Error(),
		),
	)
	f.Empty()
}

func genQueriesStruct(f *jen.File) {
	f.Type().Id(idStructQueries).Struct(
		jen.Id(idPropDb).Id(idInterfaceDb),
	)
	f.Empty()
}

func genNewFunc(f *jen.File) {
	f.Func().Id(idFuncNewQueries).Params(
		jen.Id(idParamDb).Id(idInterfaceDb),
	).Id(idInterfaceQueries).Block(
		jen.Return(jen.Op("&").Id(idStructQueries).Values(jen.Dict{
			jen.Id(idPropDb): jen.Id(idParamDb),
		})),
	).Empty()
}

func genQuery(f *jen.File, q pg.Query, im *model.Model, om *model.Model) {
	genQuerySqlConstant(f, q)

	f.Func().Params(
		jen.Id(idParamQueries).Op("*").Id(idStructQueries),
	).Id(q.Name).ParamsFunc(func(g *jen.Group) {
		g.Id(idParamCtx).Qual("context", "Context")

		if im != nil {
			g.Id(idParamInput).Qual(im.Package, im.Name)
		}
	}).ParamsFunc(func(g *jen.Group) {
		if om != nil {
			g.Index().Qual(om.Package, om.Name)
		}

		g.Error()
	}).BlockFunc(func(g *jen.Group) {
		genQueryBody(g, q, im, om)
	})
}

func genQuerySqlConstant(f *jen.File, q pg.Query) {
	f.Const().Id(getSqlConstName(q)).Op("=").Id("`\n" + q.SQL + "`")
	f.Empty()
}

func genQueryBody(g *jen.Group, q pg.Query, im *model.Model, om *model.Model) {
	if im != nil {
		genQueryInputVars(g, q, *im)
	}

	genQueryExecute(g, q, im)
	genScanRows(g, q, om)

	g.ReturnFunc(func(g *jen.Group) {
		if om != nil {
			g.Id(idVarOutput)
		}
		g.Nil()
	})
}

func genQueryInputVars(g *jen.Group, q pg.Query, im model.Model) {
	for _, in := range q.In.Inputs {
		r, _ := match.ResolveRef(im.Schema, in.Ref)

		if !isObjectOrArray(r.Schema) || (in.Type != nil && !in.Type.Json()) {
			continue
		}

		// Marshal all object and array inputs into JSON. Create a local
		// variable for each that we can later pass to the query.
		g.List(jen.Id(getVarNameForInputRef(r)), jen.Err()).Op(":=").Qual("encoding/json", "Marshal").Call(
			jen.Id(idParamInput).Dot(r.GoString()),
		)
		genHandleError(g, false)
		g.Empty()

	}
}

func genQueryExecute(g *jen.Group, q pg.Query, im *model.Model) {
	// Execute the query by calling the `Query` method on the `DB`.
	g.List(jen.Id(idVarRows), jen.Err()).Op(":=").Id(idParamQueries).Dot(idPropDb).Dot("Query").CallFunc(func(g *jen.Group) {
		genQueryInputParams(g, q, im)
	})

	// Handle `Query` method error.
	genHandleError(g, im == nil)

	// Make sure the query result is eventually closed.
	g.Defer().Id(idVarRows).Dot("Close").Call()

	g.Empty()
}

func genQueryInputParams(g *jen.Group, q pg.Query, im *model.Model) {
	g.Id(idParamCtx)
	g.Id(getSqlConstName(q))

	if im != nil {
		for _, in := range q.In.Inputs {
			r, _ := match.ResolveRef(im.Schema, in.Ref)

			if !isObjectOrArray(r.Schema) || (in.Type != nil && !in.Type.Json()) {
				g.Id(idParamInput).Dot(r.GoString())
			} else {
				// We've created local variables for all object and array inputs.
				g.Id(getVarNameForInputRef(r))
			}
		}
	}
}

func genScanRows(g *jen.Group, q pg.Query, om *model.Model) {
	if om != nil {
		// If the query has an output, create an array variable for the rows.
		g.Var().Id(idVarOutput).Index().Id(q.Out.Model)

		// Loop over all rows in the result.
		g.For(jen.Id(idVarRows).Dot("Next").Call()).BlockFunc(func(g *jen.Group) {
			genScanLoopBody(g, q, *om)
		})
	}

	g.Empty()

	// Finally check for any errors that might have occurred during scanning.
	g.If(jen.Err().Op(":=").Id(idVarRows).Dot("Err").Call(), jen.Err().Op("!=").Nil()).Block(
		jen.ReturnFunc(func(g *jen.Group) {
			if om != nil {
				g.Nil()
			}
			g.Err()
		}),
	)

	g.Empty()
}

func genScanLoopBody(g *jen.Group, q pg.Query, om model.Model) {
	// Variable for the row.
	g.Var().Id(idVarRow).Id(q.Out.Model)
	g.Empty()

	// Scan the row.
	g.If(
		jen.Err().Op(":=").Id(idVarRows).Dot("Scan").CallFunc(func(g *jen.Group) {
			genScanParams(g, q, om)
		}),
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Return(jen.Nil(), jen.Err()),
	)

	g.Empty()
	// Add the scanned row to the output.
	g.Id(idVarOutput).Op("=").Id("append").Call(
		jen.Id(idVarOutput),
		jen.Id(idVarRow),
	)
}

func genScanParams(g *jen.Group, q pg.Query, om model.Model) {
	// Loop over all root level selections.
	for _, c := range q.Out.Table.Columns {
		if r, err := match.ResolveRef(om.Schema, c.Name); err != nil {
			// Dump any targetless selections into an ephemeral sql.NullString.
			g.Op("&").Qual("database/sql", "NullString").Values()
		} else {
			g.Op("&").Id(idVarRow).Dot(r.GoString())
		}
	}
}

func isObjectOrArray(schema *model.Schema) bool {
	return schema.Type == model.TypeObject || schema.Type == model.TypeArray
}

func getVarNameForInputRef(r *match.SchemaPath) string {
	return getVarNameForRef(r, idVarInputSuffix)
}

func getVarNameForRef(r *match.SchemaPath, suffix string) string {
	name := r.Path[0]

	for _, p := range r.Path[1:] {
		name += firstUpper(p)
	}

	name += suffix

	if slices.Contains(queryLocalVars, name) {
		name += "_"
	}

	return name
}

func genHandleError(g *jen.Group, errOnly bool) {
	g.If(jen.Err().Op("!=").Nil()).Block(jen.ReturnFunc(func(g *jen.Group) {
		if !errOnly {
			g.Nil()
		}
		g.Err()
	}))
}

func writeQueriesToFile(f *jen.File, cfg config.Config, workingDir string) error {
	filePath := filepath.Join(workingDir, cfg.Package.Path, filepath.Base(cfg.Package.Path)+".go")

	if err := os.MkdirAll(filepath.Dir(filePath), 0700); err != nil {
		return err
	}

	return os.WriteFile(filePath, []byte(f.GoString()), 0600)
}

func getSqlConstName(q pg.Query) string {
	return fmt.Sprintf("%sSql", firstLower(q.Name))
}

func firstLower(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func firstUpper(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}
